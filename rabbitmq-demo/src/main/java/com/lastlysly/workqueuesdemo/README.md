## 为什么会出现 work queues?
### 前提:使用 simple 队列的时候
我们应用程序在是使用消息系统的时候,一般生产者 P 生产消息是毫不费力的(发送消息即可),而消费者接收完消息
后的需要处理,会耗费一定的时间,这时候,就有可能导致很多消息堆积在队列里面,一个消费者有可能不够用
那么怎么让消费者同事处理多个消息呢?
在同一个队列上创建多个消费者,让他们相互竞争,这样消费者就可以同时处理多条消息了
使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）
来解决这一问题，使得系统的伸缩性更加容易。

## **Round-robin（轮询分发）**

备注:消费者 1 我们处理时间是 1s ;而消费者 2 中处理时间是 2s;
但是我们看到的现象并不是 1 处理的多 消费者 2 处理的少,


测试结果:
1.消费者 1 和消费者 2 获取到的消息内容是不同的,同一个消息只能被一个消费者获取
2.消费者 1 和消费者 2 货到的消息数量是一样的 一个奇数一个偶数
按道理消费者 1 获取的比消费者 2 要多
这种方式叫做轮询分发 结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个
的分

## **4.3.2 Fair dispatch（公平分发）**
虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有 2 个消费者，所有的偶数的消息都是繁忙的，而
奇数则是轻松的。按照轮询的方式，偶数的任务交给了第一个消费者，所以一直在忙个不停。奇数的任务交给另一
个消费者，则立即完成任务，然后闲得不行。
而 RabbitMQ 则是不了解这些的。他是不知道你消费者的消费能力的,这是因为当消息进入队列，RabbitMQ 就会分派
消息。而 rabbitmq 只是盲目的将消息轮询的发给消费者。你一个我一个的这样发送
为了解决这个问题，我们使用
 #### _**basicQos( prefetchCount = 1)**_ 
 方法，来限制 RabbitMQ 只发
  #### **不超过1 ** 
  条的消息给同
一个消费者。当消息处理完毕后，有了反馈 ack，才会进行第二次发送。(也就是说需要手动反馈给 Rabbitmq )

还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。


#### 声明转发器
// 声明exchange
 channel.exchangeDeclare(EXCHANGE_NAME, "direct");
 
 